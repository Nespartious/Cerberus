# Technical Assessment of the Endgame V3 Anti-DDoS Framework
**Architectural Resilience and Mitigation Strategies for Hidden Services**

The persistent threat of distributed denial-of-service (DDoS) attacks against onion services has necessitated the development of advanced, multi-layered defensive infrastructures. Endgame V3 represents a comprehensive evolution in the field of hidden service security, integrating high-performance networking components, specialized cryptographic verification engines, and decentralized load-balancing protocols to maintain service availability within the Tor network.1 This assessment explores the technical intricacies of the Endgame V3 framework, analyzing its transition from previous iterations, the integration of memory-safe programming languages, and the strategic distribution of traffic through the GoBalance load-balancing system.2

## Architectural Paradigm and Traffic Lifecycle
The core design philosophy of Endgame V3 shifts the defensive burden from a single core application server to a distributed network of frontend nodes. This architecture is specifically engineered to mitigate the unique vulnerabilities of the Tor V3 onion service protocol, such as introduction cell flooding and circuit exhaustion.1 By acting as an intermediary layer, Endgame V3 ensures that only verified, legitimate requests reach the backend core application, thereby preserving the resources of the sensitive internal infrastructure.1

The following technical diagram outlines the request journey through the Endgame V3 ecosystem, detailing the specific components and mechanisms activated at each stage of the defensive pipeline.

| Stage | Component | Primary Function | Technical Mechanism |
|-------|-----------|------------------|---------------------|
| Ingress Point | Tor Network | Anonymous request routing | V3 Onion Routing / DH Key Exchange 4 |
| Identity Layer | Master Onion | Address consolidation | GoBalance Descriptor Management 2 |
| Network Gate | Tor Frontend | Circuit establishment | Tor V3 Protocol / Vanguards Protection 1 |
| Connection Layer | Nginx Master/Workers | Traffic termination | Event-driven I/O / Unix Domain Sockets 1 |
| Filtering Layer | Lua Security Script | Request validation | lua-nginx-module / lua-resty-random 1 |
| Verification | Rust Captcha Engine | Bot mitigation | Computationally intensive Image Generation 2 |
| Firewall Layer | NAXSI WAF | Application-level filter | Heuristic-based XSS/SQLi Prevention 1 |
| Upstream Proxy | Socat/Socks Proxy | Request forwarding | proxy_pass / socks_pass to Backend 1 |
| Backend Core | Application Server | Content delivery | Isolated Internal Service Environment 1 |

## The Evolution to GoBalance: Decentralized Load Balancing
One of the most critical transitions in the Endgame V3 framework is the replacement of the original Python-based Onionbalance with a custom implementation written in Go, designated as GoBalance.2 Go was selected as the primary language for this component, accounting for approximately 80.4% of the codebase, due to its superior handling of concurrent operations and efficient memory management compared to interpreted languages.2

GoBalance serves as a distributed DNS round-robin system specifically adapted for the Tor network's unique architecture. In traditional web environments, load balancing is typically achieved through BGP or DNS-level redirection. However, Tor services are identified by their hidden service descriptors published to the Distributed Hash Table (DHT).1 GoBalance operates by aggregating the individual descriptors generated by multiple Endgame frontend addresses and combining them into a single, master onion descriptor.1

This mechanism allows the master onion—defined in the configuration as MASTERONION—to represent a theoretically unlimited number of frontend instances.1 When a user initiates a connection to the master address, the Tor network directs the request to one of the active frontends listed in the aggregated descriptor. This distribution ensures that the computational load of managing introduction and rendezvous requests is spread across the network, eliminating single points of failure and providing a mechanism to scale out-of-band during intense attack periods.2

The GoBalance component is compiled locally from the sourcecode/gobalance directory, ensuring that the binary is optimized for the specific hardware of the master server.2 This local execution model is a security-first approach, as it removes reliance on third-party repositories and ensures that the cryptographic signing of descriptors occurs in a trusted environment.1 The high-traffic scaling capabilities of GoBalance are essential for sites that experience mass connection attempts, as it allows the operator to add more length to their defensive perimeter—a concept referred to as "scaling to the moon" within the community documentation.1

## Frontend Intelligence: Nginx and Lua Orchestration
At the tactical edge of the Endgame V3 system are the frontend nodes, which utilize a hardened version of Nginx to process incoming traffic. Nginx's architecture, characterized by a master process and multiple single-threaded worker processes, is ideally suited for the high-latency, high-concurrency environment of the Tor network.1 Unlike thread-per-request servers which may choke under heavy load, Nginx uses system-level multiplexing mechanisms to manage thousands of open connections without significant memory or CPU overhead.6

The true flexibility of the Endgame frontend is derived from the integration of Lua scripting through the lua-nginx-module.1 Lua enables the system to inject dynamic logic into the Nginx request lifecycle—specifically during the rewrite, access, and content phases—without the performance penalties associated with external application servers.6 In Endgame V3, Lua handles the core filtering logic, including:
* **Header Manipulation:** Controlling headers through the Headers More module to prevent information leakage and ensure session persistence.1
* **Session Management:** Interfacing with the lua-resty-random library to generate secure, unpredictable cookies and session tokens.1
* **Queue Control:** Implementing a time-based queue system to manage the flow of requests toward the captcha engine, preventing CPU exhaustion during mass GET attacks.1
* **Paranoia Mode:** A high-security configuration that increases the strictness of packet filtering and validation when the system detects an active DDoS event.1

Endgame V3 leverages Unix domain sockets instead of traditional TCP ports for communication between internal components.1 This approach enhances both performance and security; Unix sockets bypass the overhead of the network stack for local communications and are not exposed to potential network-based scanning or interception.1 This system-level optimization is crucial for maintaining the 3GHz+ clock speed performance required to resist single-threaded Tor bottlenecks.1

## Cryptographic Cognition: The Rust-Based Captcha Engine
A significant innovation in the V3 release is the introduction of a new captcha generation process built entirely in Rust.2 Rust constitutes approximately 5.1% of the Endgame repository and was chosen for its strict memory safety guarantees and high performance.2 The Rust-based captcha engine is designed to be lightweight, with zero runtime dependencies, which is critical for maintaining stability in high-stakes darknet environments where every CPU cycle spent on an unverified request is a potential vulnerability.2

The captcha system employs a computationally intensive "clock-facing" generation method.1 This method is strategically designed to shift the resource cost of a connection attempt from the server to the client. While the server can generate a captcha image with high efficiency using the Rust binary, the client must spend time and computational energy to solve the puzzle.1 This creates a natural rate limit for automated bots and forces attackers to invest significant resources to maintain a high volume of verified traffic.1

The synchronization between the Lua-based session management and the Rust-based captcha generation is facilitated through a set of cryptographic variables defined in the endgame.config file. These variables ensure that session tokens are valid across the entire frontend cluster.

| Configuration Variable | Standard Requirement | Role in Security Ecosystem |
|------------------------|----------------------|----------------------------|
| TORAUTHPASSWORD | Alphanumeric | Authentication for the Tor Control Port to manage circuits 1 |
| KEY | 64-128 Random Chars | Shared key used for HMAC-based session token signing 1 |
| SALT | 8 Random Chars | Cryptographic salt to prevent token prediction attacks 1 |
| SESSION_LENGTH | 3600 (1 hour) | Duration of a verified user session before re-authentication 1 |
| MASTERONION | V3 Address | The public-facing entry point consolidated by GoBalance 1 |

The use of true randomization for cookie and captcha generation—supported by the LUA Resty Random library—prevents replay attacks where an attacker might attempt to reuse a previously solved captcha to bypass the filtering layer.1 This combination of Lua's agility and Rust's performance ensures that the frontend can handle peaks in traffic without the latency spikes that typically signal a successful DDoS attack.

## Network and Transport Layer Protections
The user's inquiry regarding L2-L4 (Layer 2 to Layer 4) protections touches upon one of the most complex aspects of onion service defense. Because Tor traffic is encapsulated and routed through multiple nodes, traditional IP-based filtering at the network or data-link layers is largely ineffective against external attackers, as all incoming traffic arrives via the local loopback or a single internal proxy address.1 However, Endgame V3 addresses these lower-level concerns through several specialized mechanisms within the Tor and kernel layers.

### Tor Circuit ID Rate Limiting
The primary mechanism for traffic isolation in Endgame V3 is the utilize of Tor's V3 onion service circuit ID system.1 At the transport layer (Tor's internal L4), each connection is associated with a specific circuit ID. Endgame's Lua scripts monitor these IDs to implement primary rate limiting. Unlike IP-based limiting, which could inadvertently block thousands of users behind a single Tor relay, circuit-level limiting allows the system to identify and throttle individual aggressive circuits while maintaining access for legitimate users on other circuits.1

### The Tor PoW Patch and Vanguards
Endgame V3 includes a specific patch for the Tor source code designed to require Proof of Work (PoW) for introduction requests.2 This operates at what could be considered the "control layer" of the Tor protocol. The PoW patch forces the client's Tor daemon to perform a calculation before the introduction point—a relay node—will forward the connection request to the hidden service.2 This effectively implements a layer of filtering before the traffic even reaches the Endgame frontend, mitigating the impact of introduction cell flooding.1

Furthermore, the system incorporates Vanguards, a Python-based protection layer that prevents traffic analysis attacks.1 Vanguards hardens the service's circuit-building process by maintaining a set of long-term guard nodes and restricting the selection of middle nodes. This reduces the risk of an attacker discovering the real-world IP address of the Endgame frontends through side-channel timing analysis.1

### Kernel and System Hardening
At the operating system level (Debian 10), Endgame V3 applies various kernel-level tweaks to optimize memory allocation and network buffer handling.1 These adjustments ensure that the system remains stable under the high packet rates characteristic of a SYN flood or a mass UDP attack directed at the host's real-world IP address. While Endgame is primarily designed to filter traffic coming through Tor, these kernel-level protections are essential for maintaining the integrity of the frontend nodes against clear-web attacks.1

## Application Layer Security with NAXSI
Beyond the network and session layers, Endgame V3 provides robust application-layer (L7) protection through the NAXSI Nginx module.1 NAXSI is a high-performance, signature-less web application firewall (WAF) that utilizes a positive security model.1 Instead of attempting to identify known malicious patterns, NAXSI identifies "legitimate" request structures and flags everything else as a potential threat.

This heuristic approach is particularly effective for onion services, which may run complex backend applications (such as forums or marketplaces) that are frequent targets of SQL injection (SQLi) and Cross-Site Scripting (XSS).1 By integrating NAXSI directly into the Nginx filtering pipeline, Endgame V3 ensures that even if an attacker manages to bypass the captcha and rate-limiting layers, their ability to exploit vulnerabilities in the core application is severely restricted.1

The NAXSI configuration in Endgame includes:
* **naxsi_core.rules:** The base heuristic set for identifying anomalous request patterns.2
* **Custom Whitelists:** Tailored rules that allow legitimate application-specific traffic to pass without triggering the firewall.1
* **Lua Integration:** Lua scripts can dynamically adjust NAXSI's sensitivity based on the current attack state or the user's authentication level.1

## Hardware Specifications and Performance Optimization
The efficacy of Endgame V3 is intrinsically linked to the underlying hardware on which it is deployed. Tor's architecture remains largely single-threaded, meaning that increasing the number of CPU cores does not necessarily improve the performance of a single Tor process.1 Instead, the system prioritizes high-clocked cores—ideally at least 3GHz—to provide the necessary throughput for processing Tor cells and managing Ed25519 descriptor signing.1

| Component | Minimum Specification | Recommended Specification | Reasoning |
|-----------|-----------------------|---------------------------|-----------|
| CPU Clock Speed | 2.5 GHz | 3.0 GHz+ | Critical for single-threaded Tor cell processing 1 |
| CPU Cores | 2 Cores | 4 Cores | Offloading Lua and Rust tasks from the Tor process 1 |
| Memory (RAM) | 2 GB | 4 GB | Supporting large Nginx shared memory zones for Lua 1 |
| Storage | 20 GB SSD | 40 GB+ NVMe | Faster logging and descriptor state management 1 |
| Operating System | Debian 10 | Debian 10 (Hardened) | Specific target for Endgame installation scripts 1 |

Deploying the system on blank Debian 10 systems is recommended to avoid conflicts with existing software and to ensure that the kernel tweaks applied by the setup.sh script are effective.1 The distribution of resources is also a key consideration; while the master onion can run on a relatively modest server (2 CPU cores, 2GB RAM), the frontends require more power to handle the computationally intensive captcha generation and Nginx packet filtering.1

## Scaling Strategy: Outpacing the Attacker
The ultimate defense provided by Endgame V3 is not a static wall, but a dynamic, scalable architecture. The framework is built on the principle that the operator must have the ability to "out-dick" the attacker by scaling the number of frontends until the cost of the attack exceeds the attacker's resources.1

A minimum of three frontend nodes is recommended for any production environment.1 This provides basic redundancy; if one frontend is overwhelmed, the remaining two can continue to serve descriptors through GoBalance. However, during a sustained attack, an operator might scale to 10, 20, or 50 frontends.1 Because GoBalance aggregates these into a single master onion, the end-user experience remains unchanged, while the attacker's power is diluted across an increasingly large surface area.2

This scaling strategy is supported by the nginx-update.sh and getdependencies.sh scripts, which allow for the rapid deployment of new frontend instances.2 The use of socks_pass to reach the backend over Tor ensures that the frontends can be geographically distributed and located on different hosting providers, further enhancing the service's resilience against infrastructure-level outages or legal interventions.1

## Comparative Analysis: Endgame V3 vs. Traditional CDNs
While Endgame V3 performs functions similar to a clear-web CDN (like Cloudflare or Akamai), its operational context is fundamentally different due to the constraints of the Tor network. Traditional CDNs rely on "Anycast" routing to direct users to the nearest data center. In contrast, Endgame V3 relies on the Tor DHT and GoBalance to distribute users across hidden service frontends.1

| Feature | Clear-Web CDN | Endgame V3 (Tor) |
|---------|---------------|------------------|
| Traffic Direction | BGP / Anycast / DNS | GoBalance / Tor DHT Descriptors 2 |
| Identity Protection | Hides Origin IP | Hides both Origin and Frontend IPs 1 |
| Bot Mitigation | IP Reputation / JS Challenges | Circuit ID Limiting / Rust Captchas 1 |
| DDoS Defense | Terabit-scale scrubbing | Scaling through Introduction Point rotation 1 |
| Cost Model | Bandwidth / Request based | Self-hosted / Infrastructure costs 1 |

One of the primary advantages of Endgame V3 is the lack of "trusted middle parties." All filtering occurs on infrastructure controlled by the onion service operator, ensuring that traffic is never decrypted or inspected by a third-party entity.1 This aligns with the core privacy values of the Tor community and protects the service from the risk of a CDN provider being coerced into unmasking or censoring the service.5

## Operational Maintenance and Implementation Logic
The successful operation of Endgame V3 requires an ongoing commitment to monitoring and maintenance. The framework includes tools like NYX (a command-line monitor) and STEM (a Python controller for Tor) to provide real-time visibility into the health of the frontend nodes.1 Operators can use these tools to observe circuit counts, bandwidth usage, and the rate of rejected requests, allowing them to adjust configuration variables such as SESSION_LENGTH or NAXSI strictness in response to changing attack patterns.1

The setup process, while automated, requires careful attention to detail:
* **Deployment of GoBalance:** The master onion must be established first to create the identity of the service.1
* **Configuration Synchronization:** All frontends must use the same KEY and SALT to ensure that cookies generated on one node are valid if the user is redirected to another node by the Tor network.1
* **Core Connectivity:** The operator must decide between proxy_pass (for backends on the same local network) and socks_pass (for backends reached over Tor).1 The latter provides the highest level of isolation, as it means the frontend does not even know the physical location or local IP of the core server.1

The integration of Echo NGINX allows for shell-style commands within the Nginx configuration, providing further flexibility for advanced operators who wish to automate responses to specific attack signals.1

## Conclusion and Strategic Implications
Endgame V3 represents the current state-of-the-art in autonomous, decentralized DDoS protection for onion services. By leveraging the performance of Go for load balancing, the security of Rust for user verification, and the flexibility of Lua for packet filtering, it provides a formidable defense against both network-layer and application-layer attacks.1 The framework acknowledges that in the cat-and-mouse game of DDoS mitigation, the most effective defense is one that can scale rapidly and shift the resource cost back to the attacker.1

The movement away from Python for performance-critical components and the adoption of circuit-level rate limiting demonstrates a deep understanding of the Tor network's unique constraints.1 For operators of high-risk hidden services, Endgame V3 is not merely a tool, but a comprehensive architectural strategy for ensuring that the promise of an anonymous, uncensored web remains viable even in the face of organized opposition.1 The future of this ecosystem likely lies in the further optimization of the Tor PoW mechanisms and the continued adoption of memory-safe languages to harden the entire frontend stack against an ever-evolving threat landscape.2

## Works cited
* onionltd/EndGame: EndGame DDoS filter. - GitHub, accessed January 30, 2026, https://github.com/onionltd/EndGame
* EndGame is a front-end system that protects core application servers on an onion service, ensuring privacy without third-party reliance. Locally run and free for all to use, it combines multiple technologies to deliver secure computing magic! - GitHub, accessed January 30, 2026, https://github.com/akshzyx/EndGame
* Onionbalance - The Onion Services Ecosystem, accessed January 30, 2026, https://onionservices.torproject.org/apps/base/onionbalance/
* Setting up new v3 Hidden Service with ultimate security: Part 1, accessed January 30, 2026, https://re-ws.pl/2018/02/setting-up-new-v3-hidden-service-with-ultimate-security-part-1-hidden-service-setup/
* Hidden Services, Current Events, and Freedom Hosting | The Tor Project, accessed January 30, 2026, https://blog.torproject.org/hidden-services-current-events-and-freedom-hosting/
* A Deep Dive Into Nginx's Internal Architecture: Why It Scales When Others Choke | by J Risman | Medium, accessed January 30, 2026, https://medium.com/@j.risman217/a-deep-dive-into-nginxs-internal-architecture-why-it-scales-when-others-choke-f7600e187dee
* ️ The Long Road to Lua + ModSecurity on Nginx: Our Docker Battle Story | by Srivatsa.k, accessed January 30, 2026, https://medium.com/@srivatsa4123/%EF%B8%8F-the-long-road-to-lua-modsecurity-on-nginx-our-docker-battle-story-8afe0f5ca0a1
* Exploring the Tor Browser: Your Guide to the Onion Router - Forensic Pathways, accessed January 30, 2026, https://www.forensic-pathways.com/uncategorized/exploring-the-tor-browser-your-gateway-to-secure-and-anonymous-internet-browsing/
